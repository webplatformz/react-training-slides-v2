<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Side Effects | Essential React</title>

    <link rel="icon" href="../img/zuehlke_logo.jpg" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/webplatformz/zuehlke-reveal-package@aa0782bae9e270f4153d310e9f42bea172788e21/release/index.css"
    />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section class="deck-slide">
          <h1>
            Essential React <br />
            Side Effects
          </h1>
        </section>
        <section>
          <section>
            <h2>useEffect</h2>
            <p>What is it good for?</p>
          </section>
          <section>
            <h3>Valid useCases</h3>
            <ul>
              <li>Subscribing to events (window, ...)</li>
              <li>Releasing resources to prevent a memory leak</li>
              <li>Cancelling a network request/asynchronous operation</li>
            </ul>
          </section>
          <section>
            <pre><code class="hljs tsx" data-trim data-line-numbers="12-16|8-10|6,1-4|"><script type="text/template">
              function getWindowDimensions() {
                const { innerWidth: width, innerHeight: height } = window;
                return { width, height };
              }
              export default function MyComponent() {
                const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());
              
                const handleResize = useCallback(() => {
                  setWindowDimensions(getWindowDimensions());
                }, []);
              
                useEffect(() => {
                  handleResize();
                  window.addEventListener('resize', handleResize);
                  return () => window.removeEventListener('resize', handleResize);
                }, [handleResize]);
              /* ... */
              
          </script></code></pre>
          </section>

          <section>
            <h3>Cleanup is necessary for...</h3>
            <ul>
              <li>Unsubscribing from a pub-sub interface</li>
              <li>Releasing resources to prevent a memory leak</li>
              <li>Cancelling a network request/asynchronous operation</li>
            </ul>
          </section>
          <section>
            <h3>useEffect as last-resort</h3>
            <ul>
              <li>
                Don't use useEffect to update state based on props or state,
                whenever possible calculate all dependent states on the fly.
                <br />If necessary, use
                <span class="warn">useMemo</span>
              </li>
              <li>
                Don't notify parents on state change, whenever possible invoke
                callbacks as part of event handling logic.
              </li>
            </ul>
            <aside class="notes">
              Treat useEffect as a code smell - if you have to use it, challenge
              yourself if there is not a better way to solve the underlying
              issue
            </aside>
          </section>
        </section>
        <section>
          <section data-auto-animate>
            <h2>Exercise</h2>
            <img src="../img/search.png" />
            <p>
              Add a search input and use <span class="warn">useEffect</span> to
              implement a debounce on the pokemon list as a filter.
            </p>
          </section>
          <section data-auto-animate>
            <p>
              Add a search input and use <span class="warn">useEffect</span> to
              implement a debounce on the pokemon list as a filter.
            </p>
            <p>Use setTimeout & clearTimeout to build a delay</p>
            <pre><code class="hljs tsx" data-trim data-line-numbers="12-16|8-10|6,1-4|"><script type="text/template">
              const timeoutId = setTimeout(
                () => console.log('execute with timeout'), 300);
              clearTimeout(timeoutId); 
          </script></code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Solution</h2>
          </section>
          <section>
            <p><span class="code">SearchPanel.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers=""><script type="text/template">
              type Props = {
                searchTerm: string;
                onSearchChanged: (searchTerm: string) => void;
              };
              
              function SearchPanel({ searchTerm, onSearchChanged }: Props) {
                return (
                  <div >
                    <label htmlFor="searchTerm">Search</label>
                    <input
                      type="text"
                      id="searchTerm"
                      value={searchTerm}
                      placeholder="Pokemon name"
                      onChange={(e) => {
                        onSearchChanged(e.target.value);
                      }}
                    />
                  </div>
                );
              }
              
              export default SearchPanel;
            </script></code></pre>
          </section>
          <section>
            <p><span class="code">ListPage.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2,3|5-8"><script type="text/template">

              function ListPage() {
                const [searchTerm, setSearchTerm] = useState(initialSearchTerm);
                const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
              
                useEffect(() => {
                  const timeoutId = setTimeout(() => setDebouncedSearchTerm(searchTerm), 300);
                  return () => clearTimeout(timeoutId);
                }, [searchTerm]);
                /* ... */
              }
            </script></code></pre>
          </section>
          <section>
            <p><span class="code">ListPage.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="5|8"><script type="text/template">

              function ListPage() {
                /* ... */
                return (
                  <>
                    <SearchPanel searchTerm={searchTerm} onSearchChanged={setSearchTerm} />
                    {pokemons ? (
                      pokemons
                        ?.filter((p) => p.name.includes(debouncedSearchTerm))
                        .map((pokemon) => (
                          <PokeListEntry key={pokemon.name} name={pokemon.name} />
                        ))
                    ) : (
                      <div>LOADING</div>
                    )}
                  </>
              }
            </script></code></pre>
          </section>
        </section>
        <section>
          <section><h2>Custom Hooks</h2></section>
          <section>
            <p>
              We can reuse a concrete Hook logic by extracting it into a
              <span class="warn">custom Hook</span>.
            </p>
          </section>
          <section data-auto-animate>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2"><script type="text/template">
              function MyComponent() {
                const result = /* logic that uses Hooks */
                
                return <p>{result}</p>;
              }
          </script></code></pre>
            <p>The logic to be extracted can use a single or multiple Hooks.</p>
          </section>
          <section data-auto-animate>
            <p>We simply move the logic into its own function.</p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="1,4|2-3|7"><script type="text/template">
              function useMyCustomHook() {
                /* logic that uses Hooks */
                return result;
              }

              function MyComponent() {
                const result = useMyCustomHook();

                return <p>{result}</p>;
              }
          </script></code></pre>
            <p class="fragment">In the component we just call this function.</p>
            <p class="fragment tip">
              <span>
                Stick to the Hooks naming convention:
                <span class="code">use*</span></span
              >
            </p>
          </section>
        </section>
        <section>
          <h2>Exercise</h2>

          <p>Extract the debounce logic for the search into a custom Hook.</p>

          <div class="column-container">
            <div class="column">
              <img src="../img/construction_work_refactor.jpg" />
            </div>
          </div>
        </section>
        <section>
          <section>
            <h2>Solution</h2>
          </section>
          <section>
            <p><span class="code">usePokeList.ts</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="3|12-16"><script type="text/template">
              import { useEffect, useState } from "react";

              function useDebouncedSearch(initialSearchTerm: string) {
                const [searchTerm, setSearchTerm] = useState(initialSearchTerm);
                const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
              
                useEffect(() => {
                  const timoutId = setTimeout(() => setDebouncedSearchTerm(searchTerm), 300);
                  return () => clearTimeout(timoutId);
                }, [searchTerm]);
              
                return {
                  searchTerm,
                  setSearchTerm,
                  debouncedSearchTerm
                };
              }
              
              export default useDebouncedSearch;
              
</script></code></pre>
          </section>
          <section>
            <p><span class="code">List.tsx</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2-6"><script type="text/template">
              function ListPage() {
                const {
                  searchTerm,
                  setSearchTerm,
                  debouncedSearchTerm
                } = useDebouncedSearch("");
              
                const pokemons = usePokeList();
                /* … */
              }
              
              export default ListPage;
              
    
</script></code></pre>
          </section>
        </section>
        <section>
          <h2>Recap</h2>
          <p>We learned&hellip;</p>
          <ul>
            <li>How to use <span class="warn">useEffect</span></li>
            <li>
              When to use <span class="warn">useEffect</span> and when to use a
              different approach to reach your goal
            </li>
            <li>How to cleanup side effects in useEffect</li>
            <li>How to extract Hook logic from components into Custom Hooks</li>
          </ul>
        </section>
        <section class="deck-slide">
          <h1>Questions?</h1>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/webplatformz/zuehlke-reveal-package@aa0782bae9e270f4153d310e9f42bea172788e21/release/index.js"></script>
    <script>
      setupZuehlkeRevealPresentation();
    </script>
  </body>
</html>
