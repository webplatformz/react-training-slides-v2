<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Side Effects | Essential React</title>

    <link rel="icon" href="../img/zuehlke_logo.jpg" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/Zuehlke/zuehlke-reveal-package@f42658c99dec0812d754d935263a70b93b81f54b/release/index.css"
    />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section class="title-slide">
          <h1>Side Effects</h1>
          <h2>Essential React</h2>
        </section>
        <section>
          <section>
            <h2>useEffect</h2>
            <p>What is it good for?</p>
          </section>
          <section>
            <h3>Valid use cases</h3>
            <ul>
              <li>Subscribing to events (window, ...)</li>
              <li>Releasing resources to prevent a memory leak</li>
              <li>Cancelling a network request/asynchronous operation</li>
            </ul>
          </section>
          <!-- <section>
            <img
              src="../img/user-duplicate-request.png"
              alt="Duplicate request"
            />

            <p>What's going on here?</p>
          </section>
          <section data-auto-animate>
            <p><span class="code">index.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="5,7"><script type="text/template">
            const root = ReactDOM.createRoot(
              document.getElementById("root") as HTMLElement
            );
            root.render(
              <React.StrictMode>
                <App />
              </React.StrictMode>
            );
</script></code></pre>
            <p>
              In development, when using
              <em>Strict Mode</em>
              , components are re-mounted: mount, unmount, mount
            </p>
            <p>
              Purpose:
              <span class="hl">future-proofing</span>
              the app
            </p>
          </section>
          <section data-auto-animate>
            <p>
              In development, when using
              <em>Strict Mode</em>
              , components are re-mounted: mount, unmount, mount
            </p>
            <p>
              Purpose:
              <span class="hl">future-proofing</span>
              the app
            </p>
            <p>
              &rarr; Effects are executed at least twice in development
              <br />
              <small>(not in prod)</small>
            </p>
            <p>
              Therefore it is recommanded to not fetch data with useEffect but
              rely on a library, so let's do it!
            </p>
          </section>
          <section data-auto-animate>
            <p>Configure TanStack Query</p>
            <p>
              <span class="code">npm i @tanstack/react-query</span>
            </p>
            <pre
              data-id="code2"
            ><code class="hljs tsx" data-trim data-line-numbers="1|6-8"><script type="text/template">
              const queryClient = new QueryClient();

              function App() {
                /* Provide the client to your App */
                return (
                  <QueryClientProvider client={queryClient}>
                    <MyComponent />
                  </QueryClientProvider>
                );
              }
            </script></code></pre>
          </section> -->
          <section>
            <pre><code class="hljs tsx" data-trim data-line-numbers="12-16|8-10|6,1-4|"><script type="text/template">
              function getWindowDimensions() {
                const { innerWidth: width, innerHeight: height } = window;
                return { width, height };
              }
              export function MyComponent() {
                const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());
              
                const handleResize = useCallback(() => {
                  setWindowDimensions(getWindowDimensions());
                }, []);
              
                useEffect(() => {
                  handleResize();
                  window.addEventListener('resize', handleResize);
                  return () => window.removeEventListener('resize', handleResize);
                }, [handleResize]);
              /* ... */
              
          </script></code></pre>
          </section>

          <section>
            <h3>Cleanup is necessary for...</h3>
            <ul>
              <li>Unsubscribing from a pub-sub interface</li>
              <li>Releasing resources to prevent a memory leak</li>
              <li>Cancelling a network request/asynchronous operation</li>
            </ul>
          </section>
          <section>
            <h3>useEffect as last-resort</h3>
            <ul>
              <li>
                Don't use useEffect to update state based on props or state,
                whenever possible calculate all dependent states on the fly.
                <br />
                If the calculation is expensive, use
                <span class="hl">useMemo</span>
              </li>
              <li>
                Don't invoke callbacks on state change, whenever possible invoke
                callbacks as part of event handling logic.
              </li>
            </ul>
            <aside class="notes">
              Treat useEffect as a code smell - if you have to use it, challenge
              yourself if there is not a better way to solve the underlying
              issue
            </aside>
          </section>
        </section>
        <section>
          <section data-auto-animate>
            <h2>Exercise</h2>
            <img src="../img/search.png" />
            <p>
              Add a search input and use
              <span class="hl">useEffect</span>
              to implement a debounce on the pokemon list as a filter.
            </p>
          </section>
          <section data-auto-animate>
            <p>
              Add a search input and use
              <span class="hl">useEffect</span>
              to implement a debounce on the pokemon list as a filter.
            </p>
            <p>Use setTimeout & clearTimeout to build a delay</p>
            <pre><code class="hljs tsx" data-trim data-line-numbers="12-16|8-10|6,1-4|"><script type="text/template">
              const timeoutId = setTimeout(
                () => console.log('execute with timeout'), 300);
              clearTimeout(timeoutId); 
          </script></code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Solution</h2>
          </section>
          <section>
            <p><span class="code">SearchPanel.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers=""><script type="text/template">
              type Props = {
                searchTerm: string;
                onSearchChanged: (searchTerm: string) => void;
              };
              
              function SearchPanel({ searchTerm, onSearchChanged }: Props) {
                return (
                  <div >
                    <label htmlFor="searchTerm">Search</label>
                    <input
                      type="text"
                      id="searchTerm"
                      value={searchTerm}
                      placeholder="Pokemon name"
                      onChange={(e) => {
                        onSearchChanged(e.target.value);
                      }}
                    />
                  </div>
                );
              }
              
              export { SearchPanel };
            </script></code></pre>
          </section>
          <section>
            <p><span class="code">ListPage.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2,3|5-8"><script type="text/template">

              function ListPage() {
                const [searchTerm, setSearchTerm] = useState("");
                const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
              
                useEffect(() => {
                  const timeoutId = setTimeout(() => setDebouncedSearchTerm(searchTerm), 300);
                  return () => clearTimeout(timeoutId);
                }, [searchTerm]);
                /* ... */
              }
            </script></code></pre>
          </section>
          <section>
            <p><span class="code">ListPage.tsx</span></p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="5|8"><script type="text/template">

              function ListPage() {
                /* ... */
                return (
                  <>
                    <SearchPanel searchTerm={searchTerm} onSearchChanged={setSearchTerm} />
                    {pokemons ? (
                      pokemons
                        ?.filter((p) => p.name.includes(debouncedSearchTerm))
                        .map((pokemon) => (
                          <PokeListEntry key={pokemon.name} name={pokemon.name} />
                        ))
                    ) : (
                      <div>LOADING</div>
                    )}
                  </>
              }
            </script></code></pre>
          </section>
        </section>
        <section>
          <section><h2>Custom Hooks</h2></section>
          <section>
            <p>
              We can reuse a concrete Hook logic by extracting it into a
              <span class="hl">custom Hook</span>
              .
            </p>
          </section>
          <section data-auto-animate>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2"><script type="text/template">
              function MyComponent() {
                const result = /* logic that uses Hooks */
                
                return <p>{result}</p>;
              }
          </script></code></pre>
            <p>The logic to be extracted can use a single or multiple Hooks.</p>
          </section>
          <section data-auto-animate>
            <p>We simply move the logic into its own function.</p>
            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="1,4|2-3|7"><script type="text/template">
              function useMyCustomHook() {
                /* logic that uses Hooks */
                return result;
              }

              function MyComponent() {
                const result = useMyCustomHook();

                return <p>{result}</p>;
              }
          </script></code></pre>
            <p class="fragment">In the component we just call this function.</p>
            <p class="fragment tip">
              <span>
                Stick to the Hooks naming convention:
                <span class="code">use*</span>
              </span>
            </p>
          </section>
        </section>
        <section>
          <h2>Exercise</h2>

          <ul>
            <li>
              Extract the data fetching logic of the pokemon details page to a
              custom Hook.
            </li>
            <li>
              Stretch goal: Find a way to not have to know how the url is
              composed within the custom hook
            </li>
          </ul>
          <div>
            <img src="../img/construction_work_refactor.jpg" />
          </div>
        </section>
        <section>
          <section>
            <h2>Solution</h2>
          </section>
          <section>
            <p><span class="code">usePokemonDetails.ts</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="3|4-9|11"><script type="text/template">
              /* import ... */

              export function usePokemonDetails() {
                const { pokemonName } = useParams<"pokemonName">();
                const uri = `https://pokeapi.co/api/v2/pokemon/${pokemonName}`;
              
                const result = useQuery(["pokemon", "detail", pokemonName], () =>
                  fetcher<PokemonDetailDto>(uri)
                );
              
                return result;
              }
</script></code></pre>
          </section>
          <section>
            <p><span class="code">DetailPage.tsx</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2"><script type="text/template">
              function DetailPage() {
                const { data, isLoading, isError } = usePokemonDetails();
              
                if (isLoading) return <div>LOADING</div>;
                if (isError) return <div>ERROR while loading data</div>;
              
                return (
                  <div>
                    <span>{data.name}</span>
                    <img src={data.sprites.front_shiny} alt={data?.name} />
                  </div>
                );
              }
</script></code></pre>
          </section>
          <section>
            <p><span class="code">Stretch Goal: usePokemonDetails.ts</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="3|5"><script type="text/template">
              /* import ... */

              export function usePokemonDetails(uriBuilder: (pokemonName?: string) => string) {
                const { pokemonName } = useParams<"pokemonName">();
                const uri = uriBuilder(pokemonName);
              
                const result = useQuery(["pokemon", "detail", pokemonName], () =>
                  fetcher<PokemonDetailDto>(uri)
                );
              
                return result;
              }
</script></code></pre>
        </section>
        <section>
          <p><span class="code">Stretch Goal: DetailPage.tsx</span></p>

          <pre
            data-id="code"
          ><code class="hljs tsx" data-trim data-line-numbers="3-4|7"><script type="text/template">
            /* import ... */

            const queryUrlBuilder = (pokemonName?: string) =>
              `https://pokeapi.co/api/v2/pokemon/${pokemonName}`;
            
            function DetailPage() {
              const { data, isLoading, isError } = usePokemonDetails(queryUrlBuilder);
            
              if (isLoading) return <div>LOADING</div>;
              if (isError) return <div>ERROR while loading data</div>;
            
              return (
                <div>
                  <span>{data.name}</span>
                  <img src={data.sprites.front_shiny} alt={data?.name} />
                </div>
              );
            }
</script></code></pre>
      </section>
        <!-- <section>
          <section>
            <h2>Solution</h2>
          </section>
          <section>
            <p><span class="code">useDebouncedSearch.ts</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="3|12-16"><script type="text/template">
              import { useEffect, useState } from "react";

              function useDebouncedSearch(initialSearchTerm: string) {
                const [searchTerm, setSearchTerm] = useState(initialSearchTerm);
                const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
              
                useEffect(() => {
                  const timoutId = setTimeout(() => setDebouncedSearchTerm(searchTerm), 300);
                  return () => clearTimeout(timoutId);
                }, [searchTerm]);
              
                return {
                  searchTerm,
                  setSearchTerm,
                  debouncedSearchTerm
                };
              }
              
              export { useDebouncedSearch };
              
</script></code></pre>
          </section>
          <section>
            <p><span class="code">List.tsx</span></p>

            <pre
              data-id="code"
            ><code class="hljs tsx" data-trim data-line-numbers="2-6"><script type="text/template">
              function ListPage() {
                const {
                  searchTerm,
                  setSearchTerm,
                  debouncedSearchTerm
                } = useDebouncedSearch("");
              
                const pokemons = usePokeList();
                /* … */
              }
              
              export { ListPage };
              
    
</script></code></pre>
          </section>
        </section> -->
        <section>
          <h2>Recap</h2>
          <p>We learned&hellip;</p>
          <ul>
            <li>
              How to use
              <span class="hl">useEffect</span>
            </li>
            <li>
              When to use
              <span class="hl">useEffect</span>
              and when to use a different approach to reach your goal
            </li>
            <li>How to cleanup side effects in useEffect</li>
            <li>How to extract Hook logic from components into Custom Hooks</li>
          </ul>
        </section>
        <section class="break-slide">
          <h1>Questions?</h1>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/Zuehlke/zuehlke-reveal-package@f42658c99dec0812d754d935263a70b93b81f54b/release/index.js"></script>
    <script>
      setupZuehlkeRevealPresentation();
    </script>
  </body>
</html>
